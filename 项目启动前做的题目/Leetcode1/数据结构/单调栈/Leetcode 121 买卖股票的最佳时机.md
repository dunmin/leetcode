# Leetcode 121 买卖股票的最佳时机

### 题目描述
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

 

示例 1:
```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```
示例 2:
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 解题思路
n次价格，在i处卖出的最大收益，要么为0(当前为最小值)，要么是当前值与前面出现的最小值的差值。遍历n个卖出位置，找到收益最大的一次就好了

### 代码

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        int min_price = prices[0];
        int max_income = 0;
        for(int i=0;i<prices.size();i++){
            if(min_price>prices[i]){
                min_price = prices[i];
                continue;
            }
            else if((prices[i]-min_price) > max_income){
                max_income = prices[i]-min_price;
            }
        }
        return max_income;
    }
};
```

### 其他人的思路

#### 单调栈
这里我们维护一个单调增的栈:
+ 假如栈空或者入栈元素大于栈顶元素，直接入栈
+ 假如入栈元素小于栈顶元素则循环弹栈，直到入栈元素大于栈顶元素或者栈空
+ 在每次弹出的时候，我们拿他与栈底做差，维护一个最大值

> 为了便于最后处理的方便,我们在prices数组的末尾加上一个哨兵(也就是一个很小的元素，这里设为0)
