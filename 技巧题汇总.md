# 技巧题汇总

## 异或操作
### leetcode 136 只出现一次的数字 [位运算]
+ 简单的异或操作: 对数组中所有元素异或最后留在和里的就是只出现一次的那个
``` cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int sum=0;
        for(auto x:nums)
            sum^=x;
        return sum;
    }
};
```

### leetcode 237 删除链表中的节点 [链表]
+ 只给一个链表中的节点，保证其不是尾结点，要在链表中删除它: 由于没有其前一个节点的信息，所以显然不能直接真的删除该节点。转换思路，知道当前节点，就可以去掉下一个节点，那么就把当前的节点值与下一个节点交换并去掉下一个节点即可
``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;
    }
};
```

### leetcode 191 位1的个数 [位运算]
+ 给出1个无符号整数，求其二进制位中```1```的个数: 最直白的方法是每次```%2```看是否为```1```
``` cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n!=0){
            if(n%2==1) result += 1;
            n/=2;
        }
        return result;
    }
};
```
+ ```better```: 我们可知道，每次```i&(i-1)```会把```i```二进制表示的最后一个```1```变为```0```，因此，可以每次```&(i-1)```，如果还没为```0```说明还有```1```
![图片来源于leetcode](leetcode191_1.png)
``` cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n!=0){
            n&=(n-1);
            result++;
        }
        return result;
    }
};
```

### leetcode 283 移动零 [数组变换 快慢指针]
+ 简单的方法就直接多开一个```vector```，按顺序将原数组非```0```元素放入, 同时记录```0```个数，最后将```0```一次性放入最后
``` cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        vector<int> result;
        int cal = 0;
        for(auto x:nums){
            if(x == 0) ++cal;
            else result.push_back(x);
        }
        while(cal--)
            result.push_back(0);
        nums = result;
    }
};
```
+ ```better```: 可以使用**快慢指针**的方法降低空间复杂度到```O(1)```, 即快指针指向当前位置，慢指针指向下一个可以被填充位置，如果当前
指针指向非```0```就去填充慢指针位置。快指针到达末尾之后，慢指针一直填充```0```直到快指针的位置就行
``` cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 慢指针
        vector<int>::iterator slow_iter = nums.begin();
        // 快指针
        vector<int>::iterator fast_iter;
        for(fast_iter = nums.begin(); fast_iter!=nums.end(); ++fast_iter){
            if(*fast_iter!=0) {
                *slow_iter = *fast_iter;
                ++slow_iter;
            }
        }
        // 慢指针补0到末尾
        while(slow_iter!=fast_iter){
            *slow_iter = 0;
            ++slow_iter;
        }
    }
};
```
+ ```best```: 上面的方法在对于```[0, 0, 0.., 1]```这样的数据会补```n-1```次```0```，然而实际上只要交换```1```次就够了。
每个非```0```位置可能我们可以放到正确位置后可以马上用```0```填充(可以用交换实现)，那么之后就不用补```0```了
``` cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 慢指针
        vector<int>::iterator slow_iter = nums.begin();
        // 快指针
        vector<int>::iterator fast_iter;
        for(fast_iter = nums.begin(); fast_iter!=nums.end(); ++fast_iter){
            if(*fast_iter!=0) {
                swap(*slow_iter, *fast_iter);
                slow_iter++;
            }
        }
    }
};
```