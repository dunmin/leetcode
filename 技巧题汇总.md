# 技巧题汇总

## 异或操作
### leetcode 136 只出现一次的数字 [位运算]
+ 简单的异或操作: 对数组中所有元素异或最后留在和里的就是只出现一次的那个
``` cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int sum=0;
        for(auto x:nums)
            sum^=x;
        return sum;
    }
};
```

### leetcode 237 删除链表中的节点 [链表]
+ 只给一个链表中的节点，保证其不是尾结点，要在链表中删除它: 由于没有其前一个节点的信息，所以显然不能直接真的删除该节点。转换思路，知道当前节点，就可以去掉下一个节点，那么就把当前的节点值与下一个节点交换并去掉下一个节点即可
``` cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;
    }
};
```

### leetcode 191 位1的个数 [位运算]
+ 给出1个无符号整数，求其二进制位中```1```的个数: 最直白的方法是每次```%2```看是否为```1```
``` cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n!=0){
            if(n%2==1) result += 1;
            n/=2;
        }
        return result;
    }
};
```
+ ```better```: 我们可知道，每次```i&(i-1)```会把```i```二进制表示的最后一个```1```变为```0```，因此，可以每次```&(i-1)```，如果还没为```0```说明还有```1```
![图片来源于leetcode](leetcode191_1.png)
``` cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n!=0){
            n&=(n-1);
            result++;
        }
        return result;
    }
};
```

### leetcode 283 移动零 [数组变换 快慢指针]
+ 简单的方法就直接多开一个```vector```，按顺序将原数组非```0```元素放入, 同时记录```0```个数，最后将```0```一次性放入最后
``` cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        vector<int> result;
        int cal = 0;
        for(auto x:nums){
            if(x == 0) ++cal;
            else result.push_back(x);
        }
        while(cal--)
            result.push_back(0);
        nums = result;
    }
};
```
+ ```better```: 可以使用**快慢指针**的方法降低空间复杂度到```O(1)```, 即快指针指向当前位置，慢指针指向下一个可以被填充位置，如果当前指针指向非```0```就去填充慢指针位置。快指针到达末尾之后，慢指针一直填充```0```直到快指针的位置就行
``` cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 慢指针
        vector<int>::iterator slow_iter = nums.begin();
        // 快指针
        vector<int>::iterator fast_iter;
        for(fast_iter = nums.begin(); fast_iter!=nums.end(); ++fast_iter){
            if(*fast_iter!=0) {
                *slow_iter = *fast_iter;
                ++slow_iter;
            }
        }
        // 慢指针补0到末尾
        while(slow_iter!=fast_iter){
            *slow_iter = 0;
            ++slow_iter;
        }
    }
};
```
+ ```best```: 上面的方法在对于```[0, 0, 0.., 1]```这样的数据会补```n-1```次```0```，然而实际上只要交换```1```次就够了。每个非```0```位置可能我们可以放到正确位置后可以马上用```0```填充(可以用交换实现)，那么之后就不用补```0```了
``` cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        // 慢指针
        vector<int>::iterator slow_iter = nums.begin();
        // 快指针
        vector<int>::iterator fast_iter;
        for(fast_iter = nums.begin(); fast_iter!=nums.end(); ++fast_iter){
            if(*fast_iter!=0) {
                swap(*slow_iter, *fast_iter);
                slow_iter++;
            }
        }
    }
};
```

### leetcode 190 颠倒二进制位 [位运算、记忆化]
+ 最简单的方法就是不断直接```%2```得到二进制位重新求和构造反转出来的数
``` cpp
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        int t = 32;             // 补执行够32次会漏掉前缀0
        uint32_t result = 0;
        while(t--){
            result = result*2 + n%2;
            n/=2;
        }
        return result;
    }
};
```
+ ```change```[多次反复查询-记忆化数组]: 如果反复查询不同数的翻转二进制，那么通过记忆化数组记忆每```8```位的翻转数可以加快速度。同时，可以通过位运算完成每```8```位的翻转。即```byte```可以通过```(byte * 0x0202020202 & 0x010884422010) % 1023```得到翻转后的数[ref:Sean Eron Anderson 的在线电子书 Bit Twiddling Hacks](http://graphics.stanford.edu/~seander/bithacks.html)
``` cpp
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        // 记忆化数组
        map<uint32_t, uint32_t> re;
        int t = 4;
        int result = 0;
        while(t--){
            // 与操作求末八位
            int num = n & (0xff);
            if(re.find(num) == re.end()) 
                re[num] = reverseByte(num);
            result = (result<<8) + re[num];
            n >>= 8;
        }
        return result;
    }

    /*//普通转换法
    uint32_t reverseByte(uint32_t number){
        int result = 0;
        for(int i=7; i>=0; i--){
            // 通过移位计算
            result += ((number&1) << i);
            // 右移去末位
            number >>= 1;
        }
        return result;
    }*/

    //位运算
    uint32_t reverseByte(uint32_t number){
        return (number * 0x0202020202 & 0x010884422010) % 1023;
    }
};
```
+ ```change```[不用循环完成翻转]: 如果需要不用循环完成翻转，可以采用分治的思想，每次对半分，知道```1 bit```, 之后合并
``` cpp
// leetcode 官方提供
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        n = (n >> 16) | (n << 16);
        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);
        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);
        return n;
    }
};
```

### 242 有效的字母异位词 [排序或者哈希]
+ 哈希：使用一个```hash```先统计较长词的各个字符次数，之后遍历较短词递减，直到某个字符无法减或者最后```hash```不空，说明不是异位词: ```O(n)```
+ 排序：简单的方法是直接两串字符排序, 再依次比较: ```O(nlogn)```

### 202 快乐数: 快慢指针 [快慢指针或者哈希]
+ 题目分析: 可能有三种情况
    + 最后得到1: 快乐数
    + 出现循环:  变成判环问题
    + 一直增加到无限大，经过分析发现，```999```的各位平方和是```243```，那么比```999```小的数各位平方和肯定超不过```243```，而```9999```是```324```，以此类推，说明增加到无限大的情况是不存在的
+ 通过```hash```记录数字是否出现过，出现过就说明出现了环
+ 快慢指针: 其实类似于链表判环问题，那么可以用**弗洛伊德循环查找算法**, 即通过快慢指针，从同一点出发，慢指针每次走```1```步，快指针每次走```2```步，如果最后相遇，说明有环，所以不是快乐数