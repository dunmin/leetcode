# 技巧题汇总

## 异或操作
### leetcode 136 只出现一次的数字 [位运算]
+ 简单的异或操作: 对数组中所有元素异或最后留在和里的就是只出现一次的那个
```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int sum=0;
        for(auto x:nums)
            sum^=x;
        return sum;
    }
};
```

### leetcode 237 删除链表中的节点 [链表]
+ 只给一个链表中的节点，保证其不是尾结点，要在链表中删除它: 由于没有其前一个节点的信息，所以显然不能直接真的删除该节点。转换思路，知道当前节点，就可以去掉下一个节点，那么就把当前的节点值与下一个节点交换并去掉下一个节点即可
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node->val = node->next->val;
        node->next = node->next->next;
    }
};
```

### leetcode 191 位1的个数 [位运算]
+ 给出1个无符号整数，求其二进制位中```1```的个数: 最直白的方法是每次```%2```看是否为```1```
```
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n!=0){
            if(n%2==1) result += 1;
            n/=2;
        }
        return result;
    }
};
```
+ better: 我们可知道，每次```i&(i-1)```会把```i```二进制表示的最后一个```1```变为```0```，因此，可以每次```&(i-1)```，如果还没为```0```说明还有```1```
![n&(n-1)](leetcode191_1.png)
```
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int result = 0;
        while(n!=0){
            n&=(n-1);
            result++;
        }
        return result;
    }
};
```